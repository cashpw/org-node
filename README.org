* org-node
** What's all this

I found org-roam too slow, so I made [[https://github.com/meedstrom/quickroam][quickroam]].  And that idea spun off into this package, a standalone thing.  I hope it's also easier to learn.

- *If you were using org-roam*, there is nothing to migrate.  You can use both packages.  It's exactly the same on-disk format: "notes" are identified by their org-id.

  Thanks to shims, *you can even skip syncing the org-roam DB* but still use its features, like the rich backlinks buffer and org-roam-capture!

  In pursuit of being "just org-id", this package has no equivalent setting to =org-roam-directory= -- it just looks up =org-id-locations=.

- *If you were not using org-roam*, think of it as a limited, focused [[https://github.com/alphapapa/org-ql][org-ql]].  If you were the sort of person to prefer ID-links over file links or any other type of link, you're in the right place: this basically lets you forget about filenames and hierarchies and directory structures -- as long as you've assigned an org-id to something, you can find it later.

  And you can still keep doing hierarchies and structures, where that brings you joy, unlike systems that mandate limitations like "one note per file" or strict rules about naming files.

** What's a "node"?

My life can be divided into two periods "*before org-roam*" and "*after org-roam*".  I crossed a kind of gap once I got a good way to link between my notes.  It's odd to remember when I just relied on browsing hierarchies of subtrees -- what a strange way to do things!

At the core, all the "notetaking packages" (orgrr/zk/deft/org-roam/denote/...) try to help you with this: make it easy to link between notes.

Right off the bat, that imposes two requirements: a method to search for notes, since you can't link to something you can't search for, and a decision about exactly what kinds of things should turn up as search hits.

Just searching for Org files is too coarse, and just searching for any subtree anywhere brings in too much clutter.

Here's what org-roam invented.  It turns out that if you limit the search hits to just those files and subtrees you've deigned to assign an org-id -- which roughly maps to everything you've ever thought it was worth linking to -- it filters out the noise excellently.

Once a subtree has an ID you can link to, it's a "node" because it has joined the wider graph, the network of linked nodes.  I wish the English language had more distinct sounds for the words "node" and "note", but to clarify, I'll say "ID-node" from now on.

** Feature matrix

For your pleasure, here's a comparison of three similar notetaking systems: all permitting org-id as first-class citizen and not locking you into an "one-note-per-file" concept.

|                                   | org-roam    | org-node           | [[https://github.com/toshism/org-super-links][org-super-links]]      |
|-----------------------------------+-------------+--------------------+----------------------|
| Backlinks                         | yes         | yes                | yes                  |
| Node search and insert            | yes         | yes                | no (suggests org-ql) |
| Node aliases                      | yes         | yes                | not applicable       |
| Rich backlinks buffer             | yes         | yes (org-roam's)   | no                   |
| Reflinks                          | yes         | yes (as backlinks) | no                   |
| Ref search                        | yes         | yes (as aliases)   | no                   |
| Extract subtree to new file       | yes         | yes                | no                   |
| Can configure rich completions    | yes         | yes                | not applicable       |
| org-roam-capture integration      | yes         | yes                | no                   |
| org-capture integration           | no          | yes                | no                   |
| Backlinks in same window          | no          | yes                | yes                  |
| Avoid double-counting :BACKLINKS: | no          | yes                | yes                  |
| Warn about dead links             | no          | yes                | no                   |
| Seek files/headings sans ID       | no          | yes                | not applicable       |
| Node exclusion                    | yes         | limited            | not applicable       |
| Support =roam:= links               | yes         | no                 | no                   |
| Some query-able cache             | org-roam-db | org-nodes          | no                   |
|-----------------------------------+-------------+--------------------+----------------------|
| Cache mandatory                   | yes         | no                 | no                   |
| Time to re-cache 2000 files       | 3 minutes   | 1 second           | not applicable       |

This isn't a totally fair comparison; org-roam has an advantage in the details, see Appendix II.  With org-node I've made what I would've liked to hack on, so it's more simplistic in many aspects.

** Backlink-mode

I'll warn you now about =org-node-backlink-mode=: it adds a =CACHED_BACKLINKS= to many of your ID-nodes' property drawers.

When I first ran across that concept in [[https://github.com/toshism/org-super-links][org-super-links]], I didn't like it.  A database /inside/ the user-written file?  It seemed like clutter, and possibly easy to break.

But that's not true, it's rock solid!  There's a reason org-node caches thousands of ID-nodes in 1 second:

1. Since our permissive =org-id= system allows nested nodes (subtree nodes inside other subtrees), it makes resolving backlinks an optimization challenge.  Not only do you have to parse one file's links, you have to open and parse all the links' target files.  A naive implementation will easily run at O(N^{2}).

2. By "pre-recording" backlinks in the subtrees that concern them, the cache builder can just grab them while it grabs all the other info, leaving almost zero work to do.

Maybe you still worry about such backlinks growing stale.  So I made two systems against that: first, if you keep =org-node-backlink-mode= active all the time, it's not expected to happen unless something broke your save hooks.  It records the appearance and disappearance of links upon save.  Second, when you feel suspicious, the command =org-node-backlink-fix-all= will fix all files (slow).

**** Surprising benefit

Did you ever want to be able to see backlinks inside the Org buffer instead of in a separate window?

Well... Now they're right there.

**** It should be possible without-

Yes.  But I've come to like the =CACHED_BACKLINKS= anyway, so it's not my itch to scratch.

**** Q: Will org-roam double-count my backlinks now?

Nope!  Org-roam doesn't count links in property drawers.

** Config and setup

Add an init snippet like this (assuming [[https://github.com/radian-software/straight.el][straight.el]]):

#+begin_src elisp
(use-package org-node
  :straight (org-node :type git :host github :repo "meedstrom/org-node")
  :hook (org-mode . org-node-enable))
#+end_src

The function =org-node-enable= only runs once, and turns on two global minor modes, =org-node-cache-mode= and =org-node-backlink-mode=.  Neither mode is required, as most commands work anyway.  The cache-mode makes the commands instant, and the backlink-mode inserts corresponding backlinks whenever you insert a link.

** Commands

- =org-node-find=
  - A counterpart to =org-roam-node-find=
- =org-node-insert-link=
  - A counterpart to =org-roam-node-insert=
- =org-node-insert-include=
- =org-node-insert-transclusion=
- =org-node-insert-transclusion-as-subtree=
- =org-node-extract-subtree=
  - A bizarro counterpart to =org-roam-extract-subtree=
- =org-node-nodeify-entry=
  - Trivial: Give an ID to subtree at point (and run org-node-creation-hook)
- =org-node-create-subtree=
  - Trivial: Create a subtree with an ID (and run org-node-creation-hook)
- =org-node-random=
- =org-node-rewrite-links-ask=
  - Look for link descriptions that got out of sync with the current node title, then prompt at each link to update it
- =org-node-rename-file-by-title=
  - Auto-rename the file based on the current =#+title=
- =org-node-backlink-mass-fix=
  - Good first thing to do, to add =CACHED_BACKLINKS= everywhere
- =org-node-backlink-regret=
  - In case you regret using this package -- remove all =CACHED_BACKLINKS=

For config options, type =M-x customize-group RET org-node RET=.

** Org-capture

You may know that org-roam has its own set of capture templates: the =org-roam-capture-templates=.

It can make sense, for people who fully understand the magic of capture templates.  I didn't, so I was not confident using a second-order abstraction over an already leaky abstraction.

That's why I never got acquainted with =M-x org-roam-capture=, only indirectly using the templates via =org-roam-node-find=.  It was a jungle I didn't want to explore.

So I wondered if you can reproduce the functionality on top of vanilla org-capture.  That'd be less scary.  The answer is yes!

Set-up: write a capture template that uses =(function org-node-capture-target)= as the =target=, and then you can use it via good old =M-x org-capture= to capture to any of your ID nodes.  Something like:

#+begin_src elisp
(setq org-capture-templates
      '(("n" "ID node" plain (function org-node-capture-target))))
#+end_src

And if you want the =org-node-find= command to also outsource to org-capture when creating new nodes, use the following setting.

#+begin_src elisp
(setq org-node-creation-fn #'org-capture)
#+end_src


** For you who use Org-roam at the same time

Some user options to feel at home

#+begin_src elisp
(setq org-node-creation-fn #'org-node-new-by-roam-capture)
(setq org-node-slug-fn #'org-node-slugify-like-roam)
(setq org-node-creation-hook nil)
#+end_src

** Rich completions

How to prepend subtrees with their outline paths:

#+begin_src elisp
(setq org-node-format-candidate-fn
      (defun my-format-with-olp (node title)
        "Prepend subtree completions with the outline path."
        (if-let ((olp (plist-get node :olp)))
            (concat (string-join olp " > ") " > " title)
          title)))
#+end_src

** Getting started with backlinks

The basic commands should just work, but you see no backlinks until you run =M-x org-node-backlink-mass-fix=.

If you run into any issues, let me know!  Either here on Github or just [[mailto:meedstrom@runbox.eu][email me]] 💝

# Mention taking ownership of org-id

**** Known issues with the mass-fix

- "couldn't open /dev/stderr: too many files open"
  - Appears after about 1000 files for me.  It's not an error, just scary.  Interrupt the command and start again; it picks up where it left off, with no further complaint.
  - Two reasons the command opens all files before beginning its work -- first, it's faster that way.  For each link found, it visits the target, so any given file gets visited many times anyway.  Second, it means you can stop and resume at any time.  Very convenient when a problem comes up.

**** Enabling org-roam-buffer

You have two ways to borrow the power of =M-x org-roam-buffer-toggle=.  But first, both ways have the same limitations:

- Reflinks are represented as backlinks -- no separate reflinks heading
- It behaves as if the :unique parameter is t and :point is equal to that of the node heading.

The first way is cutting out the org-roam DB entirely:

#+begin_src elisp
(require 'org-node-roam)
(advice-add 'org-roam-backlinks-get :override
            #'org-node--fabricate-roam-backlinks)
#+end_src

The second way (experimental) is translating org-node's info into a form suitable for the org-roam DB.  This reveals just how much of the slowness of =org-roam-db-sync= came from EmacSQL/SQLite itself!

#+begin_src elisp
;; eval once
(org-node-cache-reset)
(org-node-feed-roam-db) ;; slow, maybe 1/5 of an (org-roam-db-sync 'force)

;; init snippet
(require 'org-node-roam)
(add-hook 'org-node-cache-file-hook #'org-node-feed-file-to-roam-db)
#+end_src

This second method has potential to unlock more org-roam features (like =org-roam-node-display-template=), but does not yet send all the data that org-roam wants, and given that it's slow anyway you may as well continue using the real =org-roam-db-sync= -- for now...

** Limitations
*** Excluding nodes
The =org-node-filter-fn= works well for ignoring TODO items that happen to have an ID, and ignoring org-drill items and that sort of thing, but beyond that, it has limited utility because unlike org-roam, *child ID nodes of an excluded node are not excluded!*

So let's say you have a big archive file, fulla IDs, and you want to exclude all of it.  Putting a =:ROAM_EXCLUDE: t= at the top won't do it.  As it stands, what I'd suggest is unfortunately, look at the file name.

The point of org-id is to avoid dependence on filenames, but it's often pragmatic to let up on purism just a bit :-) It works well for me to filter out any file or directory that happens to contain "archive" in the name:

#+begin_src elisp
(setq org-node-filter-fn
      (lambda (node)
        (and (not (plist-get node :exclude))
             (not (plist-get node :todo))
             (not (member "drill" (plist-get node :tags)))
             (not (string-search "archive" (plist-get node :file-path))))))
#+end_src

*** org-id

In lieu of a convenient =org-roam-update-org-id-locations=, see [[https://github.com/meedstrom/org-node?tab=readme-ov-file#appendix-iii-taking-ownership-of-org-id][Appendix III]] for how to defeat org-id's idiosyncrasies, ensuring org-node knows about all the relevant ID locations.

*** Ref format

For now, don't insert formatted links like =[[http...][description]]= in the =ROAM_REFS= field.  Just the raw URL.

** Appendix I: Rosetta stone

API comparison between org-roam and org-node.

| Action                          | org-roam                        | org-node                                                                     |
|---------------------------------+---------------------------------+------------------------------------------------------------------------------|
| Get ID at point                 | =(org-roam-id-at-point)=          | =(org-id-get nil nil nil t)=                                                   |
| Get node at point               | =(org-roam-node-at-point)=        | =(gethash (org-id-get nil nil nil t) org-nodes)=                               |
| Get list of files               | =(org-roam-list-files)=           | =(seq-uniq (hash-table-values org-id-locations))=                              |
| Prompt user to pick a node      | =(org-roam-node-read)=            | =(gethash (completing-read "Node: " org-node-collection) org-node-collection)= |
| Get backlink IDs                |                                 | =(plist-get NODE :backlink-origins)=                                           |
| Get org-roam-backlink objects   | =(org-roam-backlinks-get NODE)=   | =(org-node--fabricate-roam-backlinks (org-node--fabricate-roam-object NODE))=  |
| Get title                       | =(org-roam-node-title NODE)=      | =(plist-get NODE :title)=                                                      |
| Get ID                          | =(org-roam-node-id NODE)=         | =(plist-get NODE :id)=                                                         |
| Get filename                    | =(org-roam-node-file NODE)=       | =(plist-get NODE :file-path)=                                                  |
| Get tags                        | =(org-roam-node-tags NODE)=       | =(plist-get NODE :tags)=, no inherited tags                                    |
| Get subtree TODO state          | =(org-roam-node-todo NODE)=       | =(plist-get NODE :todo)=, only that match global =org-todo-keywords=             |
| Get outline level               | =(org-roam-node-level NODE)=      | =(plist-get NODE :level)=, also the boolean =:is-subtree=                        |
| Get =ROAM_ALIASES=                | =(org-roam-node-aliases NODE)=    | =(plist-get NODE :aliases)=                                                    |
| Get =ROAM_REFS=                   | =(org-roam-node-refs NODE)=       | =(plist-get NODE :roam-refs)=                                                  |
| Get =ROAM_EXCLUDE=                |                                 | =(plist-get NODE :exclude)=, doesn't inherit parent excludes!                  |
| Get char position               | =(org-roam-node-point NODE)=      | =(plist-get NODE :pos)=                                                        |
| Get :PROPERTIES:                | =(org-roam-node-properties NODE)= | =(plist-get NODE :properties)=                                                 |
| Get title of file where NODE is | =(org-roam-node-file-title NODE)= | =(plist-get NODE :file-title)=                                                 |
| Get subtree heading sans TODO   | =(org-roam-node-title NODE)=      | =(org-node--visit-get-true-heading NODE)=                                              |
| Get outline-path                | =(org-roam-node-olp NODE)=        | =(plist-get NODE :olp)=                                                        |
| Get subtree priority            | =(org-roam-node-priority NODE)=   |                                                                              |
| Get subtree SCHEDULED           | =(org-roam-node-scheduled NODE)=  | =(plist-get NODE :scheduled)=                                                  |
| Get subtree DEADLINE            | =(org-roam-node-deadline NODE)=   | =(plist-get NODE :deadline)=                                                   |
| Get org-roam-reflink objects    | =(org-roam-reflinks-get NODE)=    |                                                                              |
| Ensure fresh data               | =(org-roam-db-sync)=              | =(org-node-cache-ensure-fresh)=                                                |

** Appendix II: Pros of org-roam

1. It is the most general toolkit.  Take a function like =org-roam-id-at-point=.  Why does it exist, when you could use =(org-id-get nil nil nil t)=?  Well, the org-roam version ignores those ancestor headings that have an ID but have been marked not to count as "Roam nodes", so it travels further up the tree until it finds one that is indeed "a Roam node".

   - This brings good to some users.  Complexity is not the enemy.  It's just a bit of a YAML vs TOML situation.  Or lsp-mode vs eglot.  I prefer to try to be "closer to the metal", use vanilla =org-capture= instead of =org-roam-capture=, look up vanilla =org-id-locations= instead of =org-roam-directory= etc.  Not have so many wrappers.

2. Take the variable =org-roam-mode-sections=.  Under any ordinary Emacs Lisp package, this would just be a list of functions.  But in fact, you can add to it a cons cell of a function plus the arguments to pass to it.  I like programmability, but this is ... oriented towards people who aren't programmers, I think.

   - It does make the org-roam source code a slower read.  You scratch your head and ask "Why is it made that way?"  Then you see, and you say "Ah, but /I/ don't need that!"  Well, maybe someone does.

3. Take the variable =org-roam-node-display-templates=.  At least, others may consider this a pro, but for my tastes no.  I try to let people customize with little lambdas and provide examples of how they'd get some result or other.  This instead has the dream UI where you can just set the variable to a string "${olp} ${tags} ${title}" or some such and be done with it.  Problem is it's a new mini-DSL (domain-specific language), and when you learn it you miss out on an elisp lesson.  Convenient for beginners but also /keeps/ them beginners.

** Appendix III: Taking ownership of org-id

Let's say most of your Org files sit in a folder =/home/kept/notes/= but some others are outside, scattered here and there, plus you'd like to try not depending on the handy =org-roam-update-org-id-locations=.

The challenges with org-id:

1. The classic way to tell it where to look for IDs is adding the directories to =org-agenda-files=.
   - Unfortunately with thousands of files, this slows down the agenda something extreme.  Not an option.
2. An alternative way is to populate =org-id-extra-files= or =org-agenda-text-search-extra-files=.
   - See snippet A, but unfortunately with thousands of files this slows down =M-x customize-group= for org-id or org-agenda something extreme.
   - Sounds like org-id could use a patch... I'll email someone about it...eventually
3. To sidestep the small problem with #2, you could trust in org-id to keep itself updated, because it does that every time your Emacs creates or sees an ID.  You regenerate org-id-locations /once/ (or well, once every time you wipe .emacs.d).  See snippets B or C.
4. org-id complains about duplicate IDs because it's also looking in e.g. the versioned backups generated by Logseq
   - So, you need some sort of exclusion ruleset.
     - For an elisp-only way, see snippets A or B.
     - A /natural/ way is to obey =.ignore= or =.gitignore=, if you already keep such files.  I've found no elisp gitignore parser, but see snippet C for a way to use ripgrep's builtin parser.
   - Why org-roam didn't give you this problem?  It has actually been suppressing org-id errors!
5. If your Emacs quits unexpectedly, it can *forget many ID locations!*  To ensure it remembers, either use a hook like
   : (add-hook 'after-save-hook
   :  (defun my-save-id-soon ()
   :    (run-with-idle-timer 10 t #'org-id-locations-save)))
   or enable =eager-state-preempt-kill-emacs-hook-mode= from [[https://github.com/meedstrom/eager-state][eager-state]].

Snippet A
#+begin_src elisp
;; Populate `org-id-extra-files'
(dolist (file (--mapcat (directory-files-recursively it "\\.org$")
                        '(;; Example values
                          "/home/kept/notes/"
                          "/home/kept/project1/"
                          "/home/kept/project2/")))
  (when (and (not (string-search "/logseq/bak/" file))
             (not (string-search "/logseq/version-files/" file)))
    (push file org-id-extra-files)))

;; Eval to regen the `org-id-locations-file' - NOT needed each init
(org-id-update-id-locations)
#+end_src

Snippet B
#+begin_src elisp
(unless (and (file-exists-p org-id-locations-file)
             (org-id-locations-load)
             (not (hash-table-empty-p org-id-locations)))
  ;; Tell org-id without setting `org-id-extra-files'
  (org-id-update-id-locations
   (--reject (or (string-search "/logseq/bak/" it)
                 (string-search "/logseq/version-files/" it))
             (--mapcat (directory-files-recursively it "\\.org$")
                       '(;; Example values
                         "/home/kept/notes/"
                         "/home/kept/project1/"
                         "/home/kept/project2/")))))
#+end_src

Snippet C
#+begin_src elisp
(unless (and (file-exists-p org-id-locations-file)
             (org-id-locations-load)
             (not (hash-table-empty-p org-id-locations)))
  (dolist (default-directory '(;; Example values
                               "/home/kept/notes/"
                               "/home/kept/project1/"
                               "/home/kept/project2/"))
    ;; Borrow ripgrep's ability to obey .ignore/.gitignore
    (org-id-update-id-locations
     (split-string (shell-command-to-string "rg -ilt org :ID:") "\n" t))))
#+end_src


Bonus snippet: full reset

#+begin_src elisp
;; FOR TESTING: wipe all records
;; You ONLY need to wipe if it won't shut up about duplicates!
(progn (delete-file org-id-locations-file)
       (setq org-id-locations nil)
       (setq org-id--locations-checksum nil)
       (setq org-agenda-text-search-extra-files nil)
       (setq org-id-files nil)
       (setq org-id-extra-files nil))
#+end_src


* Question for you

I want to try to merge =:ROAM_REFS:= with the =:ID:= field.  I.e. let you paste URLs (or any other text string) directly on the ID field, because that's all =ROAM_REFS= are, and such a design would make it self-evident.

I think there must be many people today who remain unsure what a roam ref is, because they have a backlog of 500 other Emacs/Org concepts to learn.

Plus, such a design would mean I can run the same code to collect backlinks as reflinks, as reflinks would just /be/ backlinks.

Maybe if that doesn't pan out, we could make an =ID_ALIASES= field, so it's at least cognate to =ROAM_ALIASES=.

Or =EXTRA_IDS=.  I think that may be best.

What do you think? Awesome? Terrible?
